---
title: "Analysis of Foody et al. (2012)"
author: "Ian Hussey"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: hide
    highlight: haddock
    theme: flatly
    toc: yes
    toc_float: yes
---

```{r, include=FALSE}

knitr::opts_chunk$set(message = FALSE,
                      warning = FALSE)

```

# Dependencies and functions

```{r}

# dependencies

library(tidyverse)
library(knitr)
library(kableExtra)
library(janitor)
library(forcats)
library(patchwork)

# create director
dir.create("plots/")
dir.create("tables/")


# functions

#' Print p values to a given number of digits, always rounding up
#' @param p: p value to be rounded
#' @param digits: Number of digits to round to
round_p <- function(p, digits = 3){
  ceiling(as.numeric(p)*10^digits)/10^digits
}


#' Calculate an independent t test from summary statistics
#' @source https://stats.stackexchange.com/q/30450. Improvements made to readability and documentation, added effect sizes.
#' @param m1: the sample 1 mean
#' @param m2: the sample 2 mean
#' @param sd1: the sample 1 SD
#' @param sd2: the sample 2 SD
#' @param n1: the sample 2 sample size
#' @param n2: the sample 2 sample size
#' @param m0: the null value for the difference in means to be tested for. Default is 0. 
#' @param equal.variance: whether or not to assume equal variance. Default is FALSE as in the base R t.test function, i.e., a Welch's t-test. Setting to TRUE will produce a Student's t-test.
t_test_from_descriptives <- function(m1, m2, sd1, sd2, n1, n2, m0 = 0, equal.variance = FALSE) {
  require(psych)
  
  if(equal.variance == FALSE) {
    se <- sqrt( (sd1^2/n1) + (sd2^2/n2) )
    # welch-satterthwaite df
    df <- ( (sd1^2/n1 + sd2^2/n2)^2 )/( (sd1^2/n1)^2/(n1-1) + (sd2^2/n2)^2/(n2-1) )
  } else {
    # pooled standard deviation, scaled by the sample sizes
    se <- sqrt( (1/n1 + 1/n2) * ((n1-1)*sd1^2 + (n2-1)*sd2^2)/(n1+n2-2) ) 
    df <- n1+n2-2
  } 
  
  t <- (m1 - m2 - m0)/se 
  d <- (m1 - m2) / sqrt((sd1^2 + sd2^2)/2)
  d_cis <- psych::cohen.d.ci(d, n2 = n2, n1 = n1, alpha = .05)
  
  g <- d * ( 1 - (3 / ((4*(n1 + n2 - 2)) - 1)) ) # https://stats.stackexchange.com/q/434978 by Wolfgang Vichtbauer, creator of metafor package
  g_cis <- psych::cohen.d.ci(g, n2 = n2, n1 = n1, alpha = .05)
  
  dat <- data.frame(m1 = m1, 
                    sd1 = sd1, 
                    n1 = n1, 
                    m2 = m2, 
                    sd2 = sd2, 
                    n2 = n2,
                    mean_difference = m1 - m2,
                    se = se,
                    cohens_d = d,
                    cohens_d_ci_lower = d_cis[1],
                    cohens_d_ci_upper = d_cis[3],
                    hedges_g = g,
                    hedges_g_ci_lower = g_cis[1],
                    hedges_g_ci_upper = g_cis[3],
                    t = t, 
                    df = df,
                    p = 2 * pt(-abs(t), df))
  
  return(dat) 
}

round_all_but_p_values <- function(output, digits = 2){
  require(dplyr)
  
  output |>
    mutate(p = as.character(p)) |>
    mutate_if(is.numeric, janitor::round_half_up, digits = 2)
}

```

# Get data

```{r}

data_processed <- read_csv("../../../data/processed/foody et al 2012 publication/data_processed.csv") 

sample_size <- data_processed |>
  distinct(n) |>
  pull(n)

# check that length of sample size is 1, ie all are identical so this can be used as a numeric
length(sample_size) == 1

```

# Change from baseline to postinduction

## Assuming intervals in plot are 95% CIs

```{r}

data_baseline_postinduction <- data_processed |>
  filter(timepoint %in% c("baseline", "postinduction"))

data_change_cis <- data_baseline_postinduction |>
  select(-sd_assuming_sem) |>
  pivot_wider(names_from = timepoint, 
              values_from = c(mean, sd_assuming_ci, n)) |>
  mutate(sd_pooled = sqrt((sd_assuming_ci_baseline^2 + 
                             sd_assuming_ci_postinduction^2)/2)) |>
  rename(n = n_baseline) |>
  mutate(mean_change = mean_postinduction - mean_baseline,
         cohens_d = mean_change/sd_pooled,
         hedges_g = cohens_d * ( 1 - (3 / ((4*(n + n - 2)) - 1)) )) |>
  rowwise() |>
  mutate(lower = psych::cohen.d.ci(hedges_g, n2 = n, n1 = n, alpha = .05)[1],
         upper = psych::cohen.d.ci(hedges_g, n2 = n, n1 = n, alpha = .05)[3]) |>
  ungroup() |>
  select(outcome, 
         mean_baseline, mean_postinduction, mean_change,
         sd_baseline = sd_assuming_ci_baseline, sd_postinduction = sd_assuming_ci_postinduction, sd_pooled, n,
         hedges_g, lower, upper) 

```

## Assuming intervals in plot are SEMs

```{r}

data_change_sem <- data_baseline_postinduction |>
  select(-sd_assuming_ci) |>
  pivot_wider(names_from = timepoint, 
              values_from = c(mean, sd_assuming_sem, n)) |>
  mutate(sd_pooled = sqrt((sd_assuming_sem_baseline^2 + 
                             sd_assuming_sem_postinduction^2)/2)) |>
  rename(n = n_baseline) |>
  mutate(mean_change = mean_postinduction - mean_baseline,
         cohens_d = mean_change/sd_pooled,
         hedges_g = cohens_d * ( 1 - (3 / ((4*(n + n - 2)) - 1)) )) |>
  rowwise() |>
  mutate(lower = psych::cohen.d.ci(hedges_g, n2 = n, n1 = n, alpha = .05)[1],
         upper = psych::cohen.d.ci(hedges_g, n2 = n, n1 = n, alpha = .05)[3]) |>
  ungroup() |>
  select(outcome, 
         mean_baseline, mean_postinduction, mean_change,
         sd_baseline = sd_assuming_sem_baseline, sd_postinduction = sd_assuming_sem_postinduction, sd_pooled, n,
         hedges_g, lower, upper) 

```

## Combined 

```{r}

data_change <- 
  bind_rows(
  data_change_cis |>
    mutate(study = "Foody et al. (2012)",
           interval = "Assuming intervals are 95% CIs"),
  data_change_sem |>
    mutate(study = "Foody et al. (2012)",
           interval = "Assuming intervals are SEMs")
) |>
  mutate_if(is.numeric, janitor::round_half_up, digits = 2) |>
  select(study, outcome, interval, 
         mean_baseline, mean_postinduction, mean_change, 
         sd_baseline, sd_postinduction, sd_pooled, n,
         hedges_g, lower, upper)

data_change |>
  mutate_if(is.numeric, janitor::round_half_up, digits = 2) |>
  kable() |>
  kable_classic(full_width = FALSE)

write_csv(data_change, "tables/change baseline to postinduction.csv")

```

# Session info

```{r}

sessionInfo()

```


